class disjoint{
public:
    vector<int> parent;
    vector<int> size;
    disjoint(int n){
        parent.resize(n+1);
        size.resize(n+1);
        for(int i = 0; i < n; i++){
            parent[i] = i;
            size[i] = i;  
        }
    }

    int findulp(int node){
        if(parent[node] == node) return node;
        else return parent[node] = findulp(parent[node]);
    }

    void unionbysize(int u, int v){
        int ulp_u = findulp(u);
        int ulp_v = findulp(v);
        if(ulp_u == ulp_v) return;
        else if(size[ulp_u] < size[ulp_v]){
            parent[ulp_u] = ulp_v;
            size[ulp_v] += size[ulp_u];
        } else{
            parent[ulp_v] = ulp_u;
            size[ulp_u] += size[ulp_v];
        }
    }
};

class Solution {
public:
    int minMalwareSpread(vector<vector<int>>& graph, vector<int>& initial) {
        int n = graph.size();
        disjoint ds(n);
        
        // Non-malware nodes
        set<int> initial_nodes(initial.begin(), initial.end());
        vector<int> non_malware;
        for(int i = 0; i < n; i++){
            if(!initial_nodes.count(i)) non_malware.push_back(i);
        }

        // Union non-malware nodes
        for(auto i : non_malware){
            for(auto j : non_malware){
                if(i != j && graph[i][j]) ds.unionbysize(i, j);
            }
        }

        // Compute areas
        vector<int> area(n, 0);
        for(int i = 0; i < n; i++) area[ds.findulp(i)]++;

        // Malware influence map
        map<int, set<int>> infect_node;
        map<int, int> infect_count;
        for(auto i : initial){
            for(auto j : non_malware){
                if(graph[i][j]) infect_node[i].insert(ds.findulp(j));
            }
            for(auto j : infect_node[i]) infect_count[j]++;
        }

        // Find the best malware to remove
        int max_cnt = 0, res = initial[0];
        for(auto& [malware, nodes] : infect_node){
            int count = 0;
            for(auto& node : nodes){
                if(infect_count[node] == 1)  // Only effective when node is infected by one malware
                    count += area[node];
            }
            if(count > max_cnt || (count == max_cnt && malware < res)){
                max_cnt = count;
                res = malware;
            }
        }
        return res;
    }
};
