
class disjoint{
    public:
    vector<int> parent;
    vector<int> size;
    disjoint(int n){
        parent.resize(n+1);
        size.resize(n+1);
        for(int i=0;i<n;i++){
            parent[i]=i;
            size[i]=i;
        }
    }
        int findulp(int node){
            if(parent[node]==node) return node;
            return parent[node]=findulp(parent[node]);
        }
        void unionbysize(int u,int v){
            int ulp_u=findulp(u);
            int ulp_v=findulp(v);
            if(ulp_u==ulp_v) return;
            else if(size[ulp_u]<size[ulp_v]){
                parent[ulp_u]=ulp_v;
                size[ulp_v]+=size[ulp_u];
            } else{
                 parent[ulp_v]=ulp_u;
                size[ulp_u]+=size[ulp_v];
            }
     }
};

class Solution {
public:
    int minMalwareSpread(vector<vector<int>>& graph, vector<int>& initial) {
        int n=graph.size();
        disjoint ds(n);
        for(int i=0;i<n;i++){
            for(int j=0;j<n;j++){
                if(graph[i][j]==1) ds.unionbysize(i,j);
            }
        }
        vector<int> area(n,0);
        vector<int> malware(n,0);
        
        sort(initial.begin(),initial.end());
        int ans=initial[0];
        for(int i=0;i<n;i++) area[ds.findulp(i)]++;
        for(auto i:initial) malware[ds.findulp(i)]++;
        int maxpop=0;
        for(auto i:initial){
            if(malware[ds.findulp(i)]==1 && area[ds.findulp(i)]>maxpop){
                maxpop=area[ds.findulp(i)];
                ans=i;
            }
        }
        return ans;

    }
};